/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.mahout.classifier.chi_rw.data;

import com.google.common.collect.Lists;
import org.apache.mahout.classifier.chi_rw.data.conditions.Condition;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Random;

/**
 * Holds a list of vectors and their corresponding Dataset. contains various operations that deals with the
 * vectors (subset, count,...)
 * 
 */
public class Data implements Cloneable {
  
  private final List<Instance> instances;
  
  private final Dataset dataset;

  public Data(Dataset dataset) {
    this.dataset = dataset;
    this.instances = Lists.newArrayList();
  }

  public Data(Dataset dataset, List<Instance> instances) {
    this.dataset = dataset;
    this.instances = Lists.newArrayList(instances);
  }
  
  /**
   * @return the number of elements
   */
  public int size() {
    return instances.size();
  }
  
  /**
   * @return true if this data contains no element
   */
  public boolean isEmpty() {
    return instances.isEmpty();
  }
  
  /**
   * @param v
   *          element whose presence in this list if to be searched
   * @return true is this data contains the specified element.
   */
  public boolean contains(Instance v) {
    return instances.contains(v);
  }

    /**
   * Returns the element at the specified position
   * 
   * @param index
   *          index of element to return
   * @return the element at the specified position
   * @throws IndexOutOfBoundsException
   *           if the index is out of range
   */
  public Instance get(int index) {
    return instances.get(index);
  }
  
  /**
   * @return the subset from this data that matches the given condition
   */
  public Data subset(Condition condition) {
    List<Instance> subset = Lists.newArrayList();
    
    for (Instance instance : instances) {
      if (condition.isTrueFor(instance)) {
        subset.add(instance);
      }
    }
    
    return new Data(dataset, subset);
  }

    /**
   * if data has N cases, sample N cases at random -but with replacement.
   */
  public Data bagging(Random rng) {
    int datasize = size();
    List<Instance> bag = Lists.newArrayListWithCapacity(datasize);
    
    for (int i = 0; i < datasize; i++) {
      bag.add(instances.get(rng.nextInt(datasize)));
    }
    
    return new Data(dataset, bag);
  }
  
  /**
   * if data has N cases, sample N cases at random -but with replacement.
   * 
   * @param sampled
   *          indicating which instance has been sampled
   * 
   * @return sampled data
   */
  public Data bagging(Random rng, boolean[] sampled) {
    int datasize = size();
    List<Instance> bag = Lists.newArrayListWithCapacity(datasize);
    
    for (int i = 0; i < datasize; i++) {
      int index = rng.nextInt(datasize);
      bag.add(instances.get(index));
      sampled[index] = true;
    }
    
    return new Data(dataset, bag);
  }
  
  /**
   * Splits the data in two, returns one part, and this gets the rest of the data. <b>VERY SLOW!</b>
   */
  public Data rsplit(Random rng, int subsize) {
    List<Instance> subset = Lists.newArrayListWithCapacity(subsize);
    
    for (int i = 0; i < subsize; i++) {
      subset.add(instances.remove(rng.nextInt(instances.size())));
    }
    
    return new Data(dataset, subset);
  }
  
  /**
   * checks if all the vectors have identical attribute values
   * 
   * @return true is all the vectors are identical or the data is empty<br>
   *         false otherwise
   */
  public boolean isIdentical() {
    if (isEmpty()) {
      return true;
    }
    
    Instance instance = get(0);
    for (int attr = 0; attr < dataset.nbAttributes(); attr++) {
      for (int index = 1; index < size(); index++) {
        if (get(index).get(attr) != instance.get(attr)) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  /**
   * checks if all the vectors have identical label values
   */
  public boolean identicalLabel() {
    if (isEmpty()) {
      return true;
    }
    
    double label = dataset.getLabel(get(0));
    for (int index = 1; index < size(); index++) {
      if (dataset.getLabel(get(index)) != label) {
        return false;
      }
    }
    
    return true;
  }
  
  /**
   * finds all distinct values of a given attribute
   *//*
  public double[] values(int attr) {
    Collection<Double> result = new HashSet<Double>();
    
    for (Instance instance : instances) {
      result.add(instance.get(attr));
    }
    
    double[] values = new double[result.size()];
    
    int index = 0;
    for (Double value : result) {
      values[index++] = value;
    }
    
    return values;
  }*/
  
  public double[] values(int attr) {	  
	String[] values = dataset.getValues(attr);	
	double[] vals = new double [values.length];	
	for (int i = 0 ; i < values.length ; i++){
      vals[i] = Double.parseDouble(values[i]);
	}	  
    return vals;
  }
  
  public double getMinAttribute(int attr){	  
    double[] values = values(attr); 
	double min = values[0];
	for (int i = 1; i < values.length ; i++){
	  if (values[i] < min){              
        min = values[i];
      }
	}	  
	return min;
  }
  
  public double getMaxAttribute(int attr){
    double[] values = values(attr); 
	double max = values[0];
	for (int i = 1; i < values.length ; i++){
	  if (values[i] > max){              
        max = values[i];
      }
	}	  
	return max;  	  
  }
  
  /**
   * It returns the discourse universe for the input and output variables
   * @return double[][] The minimum [0] and maximum [1] range of each variable
   */
  public double[][] getRanges() {
    double[][] rangos = new double[dataset.nbAttributes()][2];
    //the number of input attributes of the data-set (not including the output)
    /*
    for (int i = 0; i < dataset.nbAttributes(); i++) {
      if(dataset.isNumerical(i)){	
        rangos[i][0] = getMinAttribute(i);
        rangos[i][1] = getMaxAttribute(i);
      }
      else{
    	rangos[i][0] = 0;
        rangos[i][1] = dataset.getValues(i).length - 1;  
      }
    }*/
    
    //kddcup
    /*
    rangos[0][0] = 0.0;
    rangos[0][1] = 58329.0;
    rangos[1][0] = 0.0;
    rangos[1][1] = 2.0;	
    rangos[2][0] = 0.0;
    rangos[2][1] = 67.0;	
    rangos[3][0] = 0.0;
    rangos[3][1] = 10.0;	
    rangos[4][0] = 0.0;
    rangos[4][1] = 1379963888.0;	
    rangos[5][0] = 0.0;
    rangos[5][1] = 1309937401.0;	
    rangos[6][0] = 0.0;
    rangos[6][1] = 1.0;	
    rangos[7][0] = 0.0;
    rangos[7][1] = 3.0;	
    rangos[8][0] = 0.0;
    rangos[8][1] = 14.0;	
    rangos[9][0] = 0.0;
    rangos[9][1] = 77.0;	
    rangos[10][0] = 0.0;
    rangos[10][1] = 5.0;	
    rangos[11][0] = 0.0;
    rangos[11][1] = 1.0;	
    rangos[12][0] = 0.0;
    rangos[12][1] = 7479.0;	
    rangos[13][0] = 0.0;
    rangos[13][1] = 1.0;	
    rangos[14][0] = 0.0;
    rangos[14][1] = 2.0;	
    rangos[15][0] = 0.0;
    rangos[15][1] = 7468.0;	
    rangos[16][0] = 0.0;
    rangos[16][1] = 43.0;	
    rangos[17][0] = 0.0;
    rangos[17][1] = 2.0;	
    rangos[18][0] = 0.0;
    rangos[18][1] = 9.0;	
    rangos[19][0] = 0.0;
    rangos[19][1] = 0.0;	
    rangos[20][0] = 0.0;
    rangos[20][1] = 1.0;	
    rangos[21][0] = 0.0;
    rangos[21][1] = 1.0;	
    rangos[22][0] = 0.0;
    rangos[22][1] = 511.0;	
    rangos[23][0] = 0.0;
    rangos[23][1] = 511.0;	
    rangos[24][0] = 0.0;
    rangos[24][1] = 7.0;	
    rangos[25][0] = 0.0;
    rangos[25][1] = 7.0;	
    rangos[26][0] = 0.0;
    rangos[26][1] = 7.0;	
    rangos[27][0] = 0.0;
    rangos[27][1] = 7.0;	
    rangos[28][0] = 0.0;
    rangos[28][1] = 7.0;	
    rangos[29][0] = 0.0;
    rangos[29][1] = 7.0;	
    rangos[30][0] = 0.0;
    rangos[30][1] = 7.0;	
    rangos[31][0] = 0.0;
    rangos[31][1] = 255.0;	
    rangos[32][0] = 0.0;
    rangos[32][1] = 255.0;	
    rangos[33][0] = 0.0;
    rangos[33][1] = 7.0;	
    rangos[34][0] = 0.0;
    rangos[34][1] = 7.0;	
    rangos[35][0] = 0.0;
    rangos[35][1] = 7.0;	
    rangos[36][0] = 0.0;
    rangos[36][1] = 7.0;	
    rangos[37][0] = 0.0;
    rangos[37][1] = 7.0;	
    rangos[38][0] = 0.0;
    rangos[38][1] = 7.0;	
    rangos[39][0] = 0.0;
    rangos[39][1] = 7.0;	
    rangos[40][0] = 0.0;
    rangos[40][1] = 7.0;	
    rangos[41][0] = 0.0;
    rangos[41][1] = 0.0;
    */
    //rlcp
    
    rangos[0][0] = 0.0;
    rangos[0][1] = 1.0;	
    rangos[1][0] = 0.0;
    rangos[1][1] = 1.0;	
    rangos[2][0] = 0.0;
    rangos[2][1] = 0.0;
    
    
    //poker
    /*
    rangos[0][0] = 1.0;
    rangos[0][1] = 4.0;
    rangos[1][0] = 1.0;
    rangos[1][1] = 13.0;	
    rangos[2][0] = 1.0;
    rangos[2][1] = 4.0;	
    rangos[3][0] = 1.0;
    rangos[3][1] = 13.0;	
    rangos[4][0] = 1.0;
    rangos[4][1] = 4.0;	
    rangos[5][0] = 1.0;
    rangos[5][1] = 13.0;	
    rangos[6][0] = 1.0;
    rangos[6][1] = 4.0;	
    rangos[7][0] = 1.0;
    rangos[7][1] = 13.0;	
    rangos[8][0] = 1.0;
    rangos[8][1] = 4.0;	
    rangos[9][0] = 1.0;
    rangos[9][1] = 13.0;	
    rangos[10][0] = 0.0;
    rangos[10][1] = 0.0;		
    */
    
    //fars
    /*
    rangos[0][0] = 0.0;
    rangos[0][1] = 51.0;
    rangos[1][0] = 0.0;
    rangos[1][1] = 99.0;	
    rangos[2][0] = 0.0;
    rangos[2][1] = 2.0;	
    rangos[3][0] = 0.0;
    rangos[3][1] = 10.0;	
    rangos[4][0] = 0.0;
    rangos[4][1] = 27.0;	
    rangos[5][0] = 0.0;
    rangos[5][1] = 11.0;	
    rangos[6][0] = 0.0;
    rangos[6][1] = 12.0;	
    rangos[7][0] = 0.0;
    rangos[7][1] = 3.0;	
    rangos[8][0] = 0.0;
    rangos[8][1] = 9.0;	
    rangos[9][0] = 0.0;
    rangos[9][1] = 2.0;	
    rangos[10][0] = 0.0;
    rangos[10][1] = 17.0;	
    rangos[11][0] = 0.0;
    rangos[11][1] = 3.0;	
    rangos[12][0] = 0.0;
    rangos[12][1] = 6.0;	
    rangos[13][0] = 0.0;
    rangos[13][1] = 9.0;	
    rangos[14][0] = 0.0;
    rangos[14][1] = 99.0;	
    rangos[15][0] = 0.0;
    rangos[15][1] = 3.0;	
    rangos[16][0] = 0.0;
    rangos[16][1] = 4.0;	
    rangos[17][0] = 0.0;
    rangos[17][1] = 6.0;	
    rangos[18][0] = 0.0;
    rangos[18][1] = 999.0;	
    rangos[19][0] = 0.0;
    rangos[19][1] = 6.0;	
    rangos[20][0] = 0.0;
    rangos[20][1] = 999.0;	
    rangos[21][0] = 0.0;
    rangos[21][1] = 6.0;	
    rangos[22][0] = 0.0;
    rangos[22][1] = 999.0;	
    rangos[23][0] = 0.0;
    rangos[23][1] = 8.0;	
    rangos[24][0] = 0.0;
    rangos[24][1] = 2.0;	
    rangos[25][0] = 0.0;
    rangos[25][1] = 84.0;	
    rangos[26][0] = 0.0;
    rangos[26][1] = 84.0;	
    rangos[27][0] = 0.0;
    rangos[27][1] = 84.0;	
    rangos[28][0] = 0.0;
    rangos[28][1] = 18.0;	
    rangos[29][0] = 0.0;
    rangos[29][1] = 0.0;	
    */
    
    //census
    /*
    rangos[0][0] = 0.0;
    rangos[0][1] = 90.0;
    rangos[1][0] = 0.0;
    rangos[1][1] = 8.0;	
    rangos[2][0] = 0.0;
    rangos[2][1] = 51.0;	
    rangos[3][0] = 0.0;
    rangos[3][1] = 46.0;	
    rangos[4][0] = 0.0;
    rangos[4][1] = 16.0;	
    rangos[5][0] = 0.0;
    rangos[5][1] = 9999.0;	
    rangos[6][0] = 0.0;
    rangos[6][1] = 2.0;	
    rangos[7][0] = 0.0;
    rangos[7][1] = 6.0;	
    rangos[8][0] = 0.0;
    rangos[8][1] = 23.0;	
    rangos[9][0] = 0.0;
    rangos[9][1] = 14.0;	
    rangos[10][0] = 0.0;
    rangos[10][1] = 4.0;	
    rangos[11][0] = 0.0;
    rangos[11][1] = 8.0;	
    rangos[12][0] = 0.0;
    rangos[12][1] = 1.0;	
    rangos[13][0] = 0.0;
    rangos[13][1] = 2.0;	
    rangos[14][0] = 0.0;
    rangos[14][1] = 5.0;	
    rangos[15][0] = 0.0;
    rangos[15][1] = 7.0;	
    rangos[16][0] = 0.0;
    rangos[16][1] = 99999.0;	
    rangos[17][0] = 0.0;
    rangos[17][1] = 4608.0;	
    rangos[18][0] = 0.0;
    rangos[18][1] = 99999.0;	
    rangos[19][0] = 0.0;
    rangos[19][1] = 5.0;	
    rangos[20][0] = 0.0;
    rangos[20][1] = 5.0;	
    rangos[21][0] = 0.0;
    rangos[21][1] = 49.0;	
    rangos[22][0] = 0.0;
    rangos[22][1] = 37.0;	
    rangos[23][0] = 0.0;
    rangos[23][1] = 7.0;	
    rangos[24][0] = 37.87;
    rangos[24][1] = 18656.3;	
    rangos[25][0] = 0.0;
    rangos[25][1] = 8.0;	
    rangos[26][0] = 0.0;
    rangos[26][1] = 7.0;	
    rangos[27][0] = 0.0;
    rangos[27][1] = 8.0;	
    rangos[28][0] = 0.0;
    rangos[28][1] = 2.0;	
    rangos[29][0] = 0.0;
    rangos[29][1] = 2.0;	
    rangos[30][0] = 0.0;
    rangos[30][1] = 6.0;	
    rangos[31][0] = 0.0;
    rangos[31][1] = 4.0;	
    rangos[32][0] = 0.0;
    rangos[32][1] = 41.0;	
    rangos[33][0] = 0.0;
    rangos[33][1] = 41.0;	
    rangos[34][0] = 0.0;
    rangos[34][1] = 41.0;	
    rangos[35][0] = 0.0;
    rangos[35][1] = 4.0;	
    rangos[36][0] = 0.0;
    rangos[36][1] = 2.0;	
    rangos[37][0] = 0.0;
    rangos[37][1] = 2.0;	
    rangos[38][0] = 0.0;
    rangos[38][1] = 2.0;	
    rangos[39][0] = 0.0;
    rangos[39][1] = 52.0;	
    rangos[40][0] = 94.0;
    rangos[40][1] = 95.0;	
    rangos[41][0] = 0.0;
    rangos[41][1] = 0.0;
    */
    
    //covtype
    /*
    rangos[0][0] = 2142.0;
    rangos[0][1] = 3686.0;
    rangos[1][0] = 0.0;
    rangos[1][1] = 360.0;	
    rangos[2][0] = 0.0;
    rangos[2][1] = 66.0;	
    rangos[3][0] = 0.0;
    rangos[3][1] = 1397.0;	
    rangos[4][0] = -173.0;
    rangos[4][1] = 601.0;	
    rangos[5][0] = 0.0;
    rangos[5][1] = 7117.0;	
    rangos[6][0] = 0.0;
    rangos[6][1] = 254.0;	
    rangos[7][0] = 0.0;
    rangos[7][1] = 254.0;	
    rangos[8][0] = 0.0;
    rangos[8][1] = 254.0;	
    rangos[9][0] = 0.0;
    rangos[9][1] = 7113.0;	
    rangos[10][0] = 0.0;
    rangos[10][1] = 1.0;	
    rangos[11][0] = 0.0;
    rangos[11][1] = 1.0;	
    rangos[12][0] = 0.0;
    rangos[12][1] = 1.0;	
    rangos[13][0] = 0.0;
    rangos[13][1] = 1.0;	
    rangos[14][0] = 0.0;
    rangos[14][1] = 1.0;	
    rangos[15][0] = 0.0;
    rangos[15][1] = 1.0;	
    rangos[16][0] = 0.0;
    rangos[16][1] = 1.0;	
    rangos[17][0] = 0.0;
    rangos[17][1] = 1.0;	
    rangos[18][0] = 0.0;
    rangos[18][1] = 1.0;	
    rangos[19][0] = 0.0;
    rangos[19][1] = 1.0;	
    rangos[20][0] = 0.0;
    rangos[20][1] = 1.0;	
    rangos[21][0] = 0.0;
    rangos[21][1] = 1.0;	
    rangos[22][0] = 0.0;
    rangos[22][1] = 1.0;	
    rangos[23][0] = 0.0;
    rangos[23][1] = 1.0;	
    rangos[24][0] = 0.0;
    rangos[24][1] = 1.0;	
    rangos[25][0] = 0.0;
    rangos[25][1] = 1.0;	
    rangos[26][0] = 0.0;
    rangos[26][1] = 1.0;	
    rangos[27][0] = 0.0;
    rangos[27][1] = 1.0;	
    rangos[28][0] = 0.0;
    rangos[28][1] = 1.0;	
    rangos[29][0] = 0.0;
    rangos[29][1] = 1.0;	
    rangos[30][0] = 0.0;
    rangos[30][1] = 1.0;	
    rangos[31][0] = 0.0;
    rangos[31][1] = 1.0;	
    rangos[32][0] = 0.0;
    rangos[32][1] = 1.0;	
    rangos[33][0] = 0.0;
    rangos[33][1] = 1.0;	
    rangos[34][0] = 0.0;
    rangos[34][1] = 1.0;	
    rangos[35][0] = 0.0;
    rangos[35][1] = 1.0;	
    rangos[36][0] = 0.0;
    rangos[36][1] = 1.0;	
    rangos[37][0] = 0.0;
    rangos[37][1] = 1.0;	
    rangos[38][0] = 0.0;
    rangos[38][1] = 1.0;	
    rangos[39][0] = 0.0;
    rangos[39][1] = 1.0;	
    rangos[40][0] = 0.0;
    rangos[40][1] = 1.0;	
    rangos[41][0] = 0.0;
    rangos[41][1] = 1.0;
    rangos[42][0] = 0.0;
    rangos[42][1] = 1.0;	
    rangos[43][0] = 0.0;
    rangos[43][1] = 1.0;	
    rangos[44][0] = 0.0;
    rangos[44][1] = 1.0;	
    rangos[45][0] = 0.0;
    rangos[45][1] = 1.0;	
    rangos[46][0] = 0.0;
    rangos[46][1] = 1.0;	
    rangos[47][0] = 0.0;
    rangos[47][1] = 1.0;	
    rangos[48][0] = 0.0;
    rangos[48][1] = 1.0;	
    rangos[49][0] = 0.0;
    rangos[49][1] = 1.0;
    rangos[50][0] = 0.0;
    rangos[50][1] = 1.0;	
    rangos[51][0] = 0.0;
    rangos[51][1] = 1.0;
    rangos[52][0] = 0.0;
    rangos[52][1] = 1.0;	
    rangos[53][0] = 0.0;
    rangos[53][1] = 1.0;	
    rangos[54][0] = 0.0;
    rangos[54][1] = 1.0;
    */
    return rangos;
  }
  
  /**
   * It returns the attribute labels for the input features
   * @return String[] the attribute labels for the input features
   */
  public String [] getNames(){
	//the number of input attributes of the data-set (not including the output)
    int nInputs = dataset.nbAttributes() - 1;
    String nombres[] = new String[nInputs];
    for (int i = 0; i < nInputs; i++){
      nombres[i] = "" + (i+1);
    }
    return nombres;
  }
  
  @Override
  public Data clone() {
    return new Data(dataset, Lists.newArrayList(instances));
  }
  
  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof Data)) {
      return false;
    }
    
    Data data = (Data) obj;
    
    return instances.equals(data.instances) && dataset.equals(data.dataset);
  }
  
  @Override
  public int hashCode() {
    return instances.hashCode() + dataset.hashCode();
  }
  
  /**
   * extract the labels of all instances
   */
  public double[] extractLabels() {
    double[] labels = new double[size()];
    
    for (int index = 0; index < labels.length; index++) {
      labels[index] = dataset.getLabel(get(index));
    }
    
    return labels;
  }

    /**
   * finds the majority label, breaking ties randomly<br>
   * This method can be used when the criterion variable is the categorical attribute.
   *
   * @return the majority label value
   */
  public int majorityLabel(Random rng) {
    // count the frequency of each label value
    int[] counts = new int[dataset.nblabels()];
    
    for (int index = 0; index < size(); index++) {
      counts[(int) dataset.getLabel(get(index))]++;
    }
    
    // find the label values that appears the most
    return DataUtils.maxindex(rng, counts);
  }
  
  /**
   * Counts the number of occurrences of each label value<br>
   * This method can be used when the criterion variable is the categorical attribute.
   * 
   * @param counts
   *          will contain the results, supposed to be initialized at 0
   */
  public void countLabels(int[] counts) {
    for (int index = 0; index < size(); index++) {
      counts[(int) dataset.getLabel(get(index))]++;
    }
  }
  
  public Dataset getDataset() {
    return dataset;
  }
  
  public int[] computeClassDistribution() {
	// Compute the costs for the classes
    // First, we obtain the positive class. Compute the distribution for all classes, then chose as
    // positive class the class with the lowest amount of examples
	// The number of occurrences of each label value		  		     
    int classes_distribution [] = new int [dataset.nblabels()];
    int total_examples = size();
      
    for (int i = 0; i < total_examples; i++) {
      classes_distribution[(int)dataset.getLabel(instances.get(i))]++;
    }
    return classes_distribution;
  }
}
